<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ë‘ë”ì§€ ì¡ê¸° ê²Œì„(Made By Halam)</title>
  <style>
    :root{
      --bg:#121621; --hole:#1e2332; --mole:#d25f5f; --mole-shadow:#783737;
      --white:#ffffff; --red:#e66e6e; --hud:#eaeaf0; --accent:#ffd974;
      --glass: rgba(255,255,255,.06); --ink: rgba(0,0,0,.35);
      --btn:#273150; --btnBorder: rgba(255,255,255,.15);
    }
    html,body{
      margin:0; height:100%;
      background:linear-gradient(180deg,#0f1320 0%, #121621 60%, #0f1320 100%);
      color:var(--hud);
      font-family:"Pretendard","Malgun Gothic","Apple SD Gothic Neo",system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial,sans-serif;
      overscroll-behavior:none;
    }
    .wrap{
      min-height:100%;
      display:flex; align-items:center; justify-content:center;
      padding:24px; box-sizing:border-box; gap:24px; flex-wrap:wrap;
    }
    canvas{
      width:min(640px,92vw);
      height:auto;
      aspect-ratio:640/720;
      border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.05);
      background:var(--bg);
      display:block;
      touch-action:none;
      user-select:none;
    }
    .panel{
      width:min(420px,90vw);
      background:var(--glass);
      border:1px solid rgba(255,255,255,.07);
      border-radius:16px;
      padding:16px 16px 8px;
      box-shadow:0 12px 30px var(--ink);
    }
    .panel h2{ margin:0 0 12px; font-weight:700; font-size:20px;}
    .board{ width:100%; border-collapse:collapse; font-size:14px; }
    .board th,.board td{ padding:8px; border-bottom:1px solid rgba(255,255,255,.08); text-align:left;}
    .board th{ font-weight:600; color:#bcd3ff; }
    .muted{ opacity:.8; font-size:12px; margin-top:6px;}

    .hint{
      position:fixed; bottom:14px; left:50%; transform:translateX(-50%);
      font-size:12px; opacity:.85; user-select:none; text-align:center; line-height:1.5;
      padding:6px 10px; border-radius:10px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(6px);
      max-width:min(860px,94vw);
    }
    .toast{
      position:fixed; top:12px; left:50%; transform:translateX(-50%);
      background:#1e2538; border:1px solid rgba(255,255,255,.08);
      padding:10px 14px; border-radius:10px;
      box-shadow:0 6px 20px rgba(0,0,0,.35);
      display:none;
      max-width:min(560px,92vw);
      text-align:center;
      z-index:30;
    }

    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.45);
      z-index:20;
    }
    .dialog{
      width:min(460px,92vw);
      background:#192033; border:1px solid rgba(255,255,255,.12);
      border-radius:16px; padding:18px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
    }
    .dialog h3{ margin:0 0 12px; font-size:18px;}
    .dialog p{ margin:8px 0 12px; font-size:14px; opacity:.92;}
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    input[type="text"]{
      flex:1; min-width:200px;
      background:#0f1526; border:1px solid rgba(255,255,255,.15);
      color:#eef3ff; padding:10px 12px; border-radius:10px; outline:none;
    }
    button{
      background:var(--btn); color:#eaf1ff; border:1px solid var(--btnBorder);
      padding:10px 14px; border-radius:10px; cursor:pointer;
    }
    button:hover{ filter:brightness(1.05); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .danger{ background:#5a2630; border-color:#8a3948; }

    /* HUD ë²„íŠ¼ (ìº”ë²„ìŠ¤ ìœ„) */
    .hudbar{
      position:fixed;
      top:12px; right:12px;
      display:flex; gap:8px;
      z-index:10;
    }
    .hudbar button{
      padding:9px 12px;
      font-size:13px;
      border-radius:10px;
      background: rgba(39,49,80,.85);
      backdrop-filter: blur(6px);
    }

    a{ color:#9ad0ff; text-decoration:none; } a:hover{ text-decoration:underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="640" height="720" aria-label="ë‘ë”ì§€ ì¡ê¸° ê²Œì„ ìº”ë²„ìŠ¤" role="img"></canvas>

    <div class="panel">
      <h2>ğŸ† ë¦¬ë”ë³´ë“œ (Top 10)</h2>
      <table class="board">
        <thead>
          <tr><th>#</th><th>ë‹‰ë„¤ì„</th><th>ì ìˆ˜</th><th>ìµœëŒ€ ì½¤ë³´</th><th>ë‚ ì§œ</th></tr>
        </thead>
        <tbody id="board-body">
          <tr><td colspan="5">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤â€¦</td></tr>
        </tbody>
      </table>
      <div class="muted">ê²Œì„ ì˜¤ë²„ í›„ Top 10ì— ë“¤ë©´ ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
    </div>
  </div>

  <div class="hudbar">
    <button id="btnStart">ì‹œì‘</button>
    <button id="btnPause">ì¼ì‹œì •ì§€</button>
    <button id="btnRestart">ì¬ì‹œì‘</button>
  </div>

  <div class="hint" id="hint">
    Space ì‹œì‘ Â· (ëª¨ë°”ì¼) í™”ë©´ í„°ì¹˜ë¡œ íƒ€ê²© Â· P ì¼ì‹œì •ì§€ Â· R ì¬ì‹œì‘
  </div>
  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <!-- Top10 ë‹‰ë„¤ì„ -->
  <div class="overlay" id="nameOverlay" role="dialog" aria-modal="true">
    <div class="dialog">
      <h3>Top 10ì— ì§„ì…í–ˆìŠµë‹ˆë‹¤</h3>
      <p>ë¦¬ë”ë³´ë“œì— í‘œì‹œí•  ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”. (2~12ì, í•œê¸€/ì˜ë¬¸/ìˆ«ì/ê³µë°±/_/-)</p>
      <div class="row">
        <input type="text" id="nickname" placeholder="ë‹‰ë„¤ì„" maxlength="12" autocomplete="off" />
        <button id="submitName">ì €ì¥</button>
        <button class="danger" id="cancelName">ì·¨ì†Œ</button>
      </div>
    </div>
  </div>

  <script>
    // ===== ì„œë²„ ì—”ë“œí¬ì¸íŠ¸ =====
    const API_BASE = (location.hostname === "localhost")
      ? "http://localhost:3000"
      : "https://halam.cloud";

    // ===== ìƒìˆ˜/ìœ í‹¸ =====
    const W = 640, H = 720;
    const TAU = Math.PI * 2;
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const font = (px=28)=>`${px}px "Malgun Gothic","Apple SD Gothic Neo",system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial,sans-serif`;

    const COLORS = {
      BG: getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || "#121621",
      HOLE: getComputedStyle(document.documentElement).getPropertyValue('--hole').trim() || "#1e2332",
      MOLE: getComputedStyle(document.documentElement).getPropertyValue('--mole').trim() || "#d25f5f",
      MOLE_SHADOW: getComputedStyle(document.documentElement).getPropertyValue('--mole-shadow').trim() || "#783737",
      WHITE: "#ffffff",
      HUD: getComputedStyle(document.documentElement).getPropertyValue('--hud').trim() || "#eaeaf0",
      RED: getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || "#e66e6e",
      ACCENT: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || "#ffd974"
    };

    const STATE_MENU = 0, STATE_PLAY = 1, STATE_PAUSE = 2, STATE_GAMEOVER = 3;

    // ===== ìº”ë²„ìŠ¤(ë ˆí‹°ë‚˜) =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha:false });

    let DPR = 1;
    function setupCanvas(){
      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.imageSmoothingEnabled = true;
    }
    setupCanvas();
    window.addEventListener('resize', setupCanvas, { passive:true });

    function drawTextCenter(text, size, color, cx, cy){
      ctx.font = font(size);
      ctx.fillStyle = color;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(text, cx, cy);
    }

    // ===== ì…ë ¥(í¬ì¸í„°) =====
    let pointer = { x:0, y:0, justPressed:false, isTouch:false };

    function updatePointer(e){
      const rect = canvas.getBoundingClientRect();
      const sx = rect.width / W;
      const sy = rect.height / H;
      pointer.x = (e.clientX - rect.left) / sx;
      pointer.y = (e.clientY - rect.top) / sy;
    }

    canvas.addEventListener('pointermove', (e)=>{ updatePointer(e); }, { passive:true });

    canvas.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      pointer.isTouch = (e.pointerType === "touch");
      canvas.setPointerCapture(e.pointerId);
      updatePointer(e);
      pointer.justPressed = true;

      // ë©”ë‰´ì—ì„œ í„°ì¹˜ë¡œ ë°”ë¡œ ì‹œì‘
      if(game.state === STATE_MENU){
        topHint = "";
        game.reset();
        game.state = STATE_PLAY;
      }
    }, { passive:false });

    // ===== í† ìŠ¤íŠ¸ =====
    const toastEl = document.getElementById('toast');
    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.style.display = 'block';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>{ toastEl.style.display='none'; }, 1800);
    }

    // ===== íŒŒí‹°í´(í’€ë§) =====
    class Particle {
      constructor(){ this.active=false; }
      init(x,y,color){
        const ang = rand(0,TAU), spd = rand(2,6);
        this.x=x; this.y=y;
        this.vx=Math.cos(ang)*spd; this.vy=Math.sin(ang)*spd;
        this.life = rand(0.25, 0.45); // seconds
        this.color=color;
        this.size=rand(2,4);
        this.active=true;
      }
      update(dt){
        if(!this.active) return;
        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.96; this.vy *= 0.96;
        this.life -= dt;
        if(this.life <= 0) this.active=false;
      }
      draw(c){
        if(!this.active) return;
        const r = Math.max(1, this.size * (this.life/0.45));
        c.fillStyle=this.color;
        c.beginPath(); c.arc(this.x, this.y, r, 0, TAU); c.fill();
      }
    }

    class ParticlePool {
      constructor(cap=240){
        this.pool = Array.from({length:cap}, ()=>new Particle());
        this.cursor = 0;
      }
      emit(x,y,color,count=18){
        for(let i=0;i<count;i++){
          const p = this.pool[this.cursor];
          this.cursor = (this.cursor + 1) % this.pool.length;
          p.init(x,y,color);
        }
      }
      update(dt){ for(const p of this.pool) p.update(dt); }
      draw(c){ for(const p of this.pool) p.draw(c); }
    }

    // ===== í”Œë¡œíŒ… ì ìˆ˜ =====
    class FloatText {
      constructor(){ this.active=false; }
      init(x,y,text,color){
        this.x=x; this.y=y;
        this.text=text; this.color=color;
        this.life=0.8;
        this.vy=-40;
        this.active=true;
      }
      update(dt){
        if(!this.active) return;
        this.life -= dt;
        this.y += this.vy*dt;
        if(this.life<=0) this.active=false;
      }
      draw(c){
        if(!this.active) return;
        c.font = font(18);
        c.textAlign="center"; c.textBaseline="middle";
        c.fillStyle = this.color;
        c.globalAlpha = clamp(this.life/0.8, 0, 1);
        c.fillText(this.text, this.x, this.y);
        c.globalAlpha = 1;
      }
    }

    class FloatTextPool {
      constructor(cap=40){
        this.pool = Array.from({length:cap}, ()=>new FloatText());
        this.cursor = 0;
      }
      pop(x,y,text,color){
        const f = this.pool[this.cursor];
        this.cursor = (this.cursor + 1) % this.pool.length;
        f.init(x,y,text,color);
      }
      update(dt){ for(const f of this.pool) f.update(dt); }
      draw(c){ for(const f of this.pool) f.draw(c); }
    }

    // ===== ë‘ë”ì§€(ì‹œê°„ ê¸°ë°˜) =====
    class Mole {
      constructor(cx,cy){
        this.cx=cx; this.cy=cy;
        this.baseR=36;
        this.state="hidden";
        this.t=0;
        this.visibleDur=0.7;
        this.appearDur=0.16;
        this.disappearDur=0.13;
        this.wasHit=false;
      }
      spawn(visibleSeconds){
        this.state="appearing"; this.t=0; this.wasHit=false;
        this.visibleDur = Math.max(0.28, visibleSeconds);
      }
      isClickable(){ return this.state==="appearing" || this.state==="visible"; }
      currentRadius(){
        if(this.state==="appearing"){
          const k = clamp(this.t/this.appearDur,0,1);
          return this.baseR*(0.2+0.8*k);
        }
        if(this.state==="visible"){
          const pulse = 0.04*Math.sin(this.t*10);
          return this.baseR*(1+pulse);
        }
        if(this.state==="disappearing"){
          const k = 1 - clamp(this.t/this.disappearDur,0,1);
          return this.baseR*(0.2+0.8*k);
        }
        return this.baseR*0.2;
      }
      contains(x,y,isTouch){
        const r=this.currentRadius();
        const bonus = isTouch ? 1.15 : 1.0; // í„°ì¹˜ íŒì • ë³´ì •
        const rr = (r*0.9*bonus);
        const dx=x-this.cx, dy=y-this.cy;
        return dx*dx+dy*dy <= rr*rr;
      }
      update(dt){
        if(this.state==="hidden") return;
        this.t += dt;

        if(this.state==="appearing" && this.t>=this.appearDur){
          this.state="visible"; this.t=0;
        } else if(this.state==="visible" && this.t>=this.visibleDur){
          this.state="disappearing"; this.t=0;
        } else if(this.state==="disappearing" && this.t>=this.disappearDur){
          this.state="hidden"; this.t=0;
        }
      }
      hit(){
        if(this.isClickable() && !this.wasHit){
          this.wasHit=true;
          this.state="disappearing"; this.t=0;
          return true;
        }
        return false;
      }
      drawMole(c){
        if(this.state==="hidden") return;
        const r=this.currentRadius();

        c.fillStyle=COLORS.MOLE_SHADOW;
        c.beginPath(); c.arc(this.cx,this.cy+3,r,0,TAU); c.fill();

        c.fillStyle=COLORS.MOLE;
        c.beginPath(); c.arc(this.cx,this.cy,r,0,TAU); c.fill();

        const eyeR=Math.max(2, r/8);
        c.fillStyle="#1e1e1e";
        c.beginPath(); c.arc(this.cx-r/3,this.cy-r/5,eyeR,0,TAU); c.fill();
        c.beginPath(); c.arc(this.cx+r/3,this.cy-r/5,eyeR,0,TAU); c.fill();

        const noseR=Math.max(2, r/6);
        c.fillStyle="#ffaaaa";
        c.beginPath(); c.arc(this.cx,this.cy,noseR,0,TAU); c.fill();
      }
    }

    // ===== ì •ì  ë°°ê²½(êµ¬ë©) ë¯¸ë¦¬ ê·¸ë¦¬ê¸° =====
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = W; bgCanvas.height = H;
    const bgCtx = bgCanvas.getContext('2d');

    function renderStaticBackground(holeCenters){
      bgCtx.fillStyle = COLORS.BG;
      bgCtx.fillRect(0,0,W,H);

      // êµ¬ë©ë§Œ ë¯¸ë¦¬ ë Œë”
      bgCtx.fillStyle = COLORS.HOLE;
      for(const [x,y] of holeCenters){
        const shadowR = 36*1.15;
        bgCtx.beginPath();
        bgCtx.arc(x,y,shadowR,0,TAU);
        bgCtx.fill();
      }
    }

    // ===== ê²Œì„ =====
    class Game {
      constructor(){
        this.state = STATE_MENU;
        this.timeLimit = 30;

        this.highScore = Number(localStorage.getItem("wam_high_score") || 0);

        // í™”ë©´ í”ë“¤ë¦¼(ë¯¸ìŠ¤ í”¼ë“œë°±)
        this.shakeT = 0;
        this.shakePower = 0;

        this.reset();
      }

      reset(){
        const marginX=80, marginY=160;
        const gapX=((W-marginX*2)/2);
        const gapY=((H-marginY-120)/2);

        this.centers=[];
        for(let gy=0; gy<3; gy++){
          for(let gx=0; gx<3; gx++){
            this.centers.push([marginX+gx*gapX+40, marginY+gy*gapY+40]);
          }
        }

        this.moles = this.centers.map(([x,y])=>new Mole(x,y));
        renderStaticBackground(this.centers);

        this.score=0; this.combo=0; this.maxCombo=0;
        this.elapsed=0; this.spawnTimer=0;

        // ë‚œì´ë„(ì´ˆ)
        this.baseVisible = 0.80;
        this.visible = this.baseVisible;
        this.spawnInterval = 0.95;

        // ì ì‘ êµ¬ê°„
        this.warmup = 4.0; // first 4 seconds easier

        this.particles = new ParticlePool(240);
        this.floatText = new FloatTextPool(42);
      }

      updateDifficulty(){
        const p = clamp(this.elapsed/this.timeLimit, 0, 1);

        // ì›Œë°ì—… ë™ì•ˆ ë‚œì´ë„ ì™„í™”
        const warm = clamp(this.elapsed/this.warmup, 0, 1);

        const targetVisible = Math.max(0.28, this.baseVisible - 0.38*p);
        const targetInterval = Math.max(0.35, 0.95 - 0.60*p);

        // warmì´ 1ì— ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ ëª©í‘œ ë‚œì´ë„ì— ìˆ˜ë ´
        this.visible = this.baseVisible*(1-warm) + targetVisible*warm;
        this.spawnInterval = 1.05*(1-warm) + targetInterval*warm;
      }

      spawnLogic(){
        const hidden = this.moles.filter(m=>m.state==="hidden");
        if(hidden.length){
          hidden[(Math.random()*hidden.length)|0].spawn(this.visible);
        }
      }

      missFeedback(){
        // ì•„ì£¼ ì§§ì€ í™”ë©´ í”ë“¤ë¦¼
        this.shakeT = 0.12;
        this.shakePower = 6;
      }

      updateShake(dt){
        if(this.shakeT>0){
          this.shakeT -= dt;
          if(this.shakeT<=0){ this.shakeT=0; this.shakePower=0; }
        }
      }

      getShakeOffset(){
        if(this.shakeT<=0) return {x:0,y:0};
        const k = this.shakeT / 0.12;
        const amp = this.shakePower * k;
        return { x: rand(-amp, amp), y: rand(-amp, amp) };
      }
    }

    const game = new Game();
    let last = performance.now();
    let topHint = "";

    // ===== í‚¤ ì…ë ¥ =====
    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space' && game.state===STATE_MENU){
        topHint="";
        game.reset(); game.state=STATE_PLAY;
      } else if(e.code==='KeyR' && (game.state===STATE_GAMEOVER || game.state===STATE_PAUSE || game.state===STATE_PLAY)){
        topHint="";
        game.reset(); game.state=STATE_PLAY;
      } else if(e.code==='KeyP'){
        if(game.state===STATE_PLAY) game.state=STATE_PAUSE;
        else if(game.state===STATE_PAUSE) game.state=STATE_PLAY;
      }
    });

    // ===== HUD ë²„íŠ¼ =====
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnRestart = document.getElementById('btnRestart');
    btnStart.addEventListener('click', ()=>{
      if(game.state===STATE_MENU || game.state===STATE_GAMEOVER){
        topHint="";
        game.reset(); game.state=STATE_PLAY;
      }
    });
    btnPause.addEventListener('click', ()=>{
      if(game.state===STATE_PLAY) game.state=STATE_PAUSE;
      else if(game.state===STATE_PAUSE) game.state=STATE_PLAY;
    });
    btnRestart.addEventListener('click', ()=>{
      topHint="";
      game.reset(); game.state=STATE_PLAY;
    });

    // ===== ë©”ì¸ ì—…ë°ì´íŠ¸ =====
    function update(dt){
      if(game.state===STATE_PLAY){
        game.elapsed += dt;
        game.spawnTimer += dt;

        game.updateDifficulty();

        while(game.spawnTimer >= game.spawnInterval){
          game.spawnTimer -= game.spawnInterval;
          game.spawnLogic();
        }

        for(const m of game.moles) m.update(dt);

        if(pointer.justPressed){
          let hit=false;

          // 1íšŒ ì…ë ¥ë‹¹ 1ë§ˆë¦¬ë§Œ
          for(const m of game.moles){
            if(m.contains(pointer.x, pointer.y, pointer.isTouch) && m.hit()){
              hit=true;
              const gain = 10 + game.combo*2;
              game.score += gain;
              game.combo += 1;
              game.maxCombo = Math.max(game.maxCombo, game.combo);

              game.particles.emit(pointer.x, pointer.y, COLORS.ACCENT, 18);
              game.floatText.pop(pointer.x, pointer.y-10, `+${gain}`, COLORS.ACCENT);
              break;
            }
          }

          if(!hit){
            const prevCombo = game.combo;
            game.combo = 0;
            game.score = Math.max(0, game.score-5);
            game.missFeedback();
            game.floatText.pop(pointer.x, pointer.y-10, `MISS`, COLORS.RED);

            // ì½¤ë³´ê°€ ì»¸ë‹¤ë©´ ì•ˆë‚´(ê³¼ë„í•œ ìŠ¤íŒ¸ ë°©ì§€ìš©ìœ¼ë¡œ ì¡°ê±´)
            if(prevCombo >= 8){
              showToast(`ì½¤ë³´ ${prevCombo}ì—ì„œ ëŠê²¼ìŠµë‹ˆë‹¤.`);
            }
          }
        }

        // ì´í™íŠ¸ ì—…ë°ì´íŠ¸
        game.particles.update(dt);
        game.floatText.update(dt);
        game.updateShake(dt);

        if(game.elapsed >= game.timeLimit){
          game.state = STATE_GAMEOVER;

          if(game.score > game.highScore){
            game.highScore = game.score;
            localStorage.setItem("wam_high_score", String(game.highScore));
          }

          probeAndMaybeAskName(game.score, game.maxCombo);
        }
      } else if(game.state===STATE_PAUSE){
        // ì¼ì‹œì •ì§€ ì¤‘ì—ë„ í”ë“¤ë¦¼ ì”ìƒë§Œ ì •ë¦¬
        game.updateShake(dt);
      }

      pointer.justPressed = false;
    }

    // ===== ë Œë” =====
    function draw(){
      // ë°°ê²½(êµ¬ë© í¬í•¨) ë¨¼ì €
      ctx.drawImage(bgCanvas, 0, 0);

      // í”ë“¤ë¦¼ ì ìš©(ê²Œì„ í”Œë ˆì´/ì˜¤ë²„ì—ì„œë§Œ)
      const shake = (game.state===STATE_PLAY) ? game.getShakeOffset() : {x:0,y:0};
      ctx.save();
      ctx.translate(shake.x, shake.y);

      // ë‘ë”ì§€
      for(const m of game.moles) m.drawMole(ctx);

      // íŒŒí‹°í´/í…ìŠ¤íŠ¸
      game.particles.draw(ctx);
      game.floatText.draw(ctx);

      ctx.restore();

      // HUD
      if(game.state===STATE_MENU){
        drawTextCenter("ë‘ë”ì§€ ì¡ê¸° ê²Œì„", 64, COLORS.WHITE, W/2, H/2-90);
        drawTextCenter("Space ë˜ëŠ” ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì‹œì‘", 28, COLORS.WHITE, W/2, H/2-20);
        drawTextCenter("ëª¨ë°”ì¼ì€ í™”ë©´ì„ í„°ì¹˜í•´ë„ ì‹œì‘ë©ë‹ˆë‹¤", 22, COLORS.HUD, W/2, H/2+20);
        drawTextCenter(`ìµœëŒ€ ì ìˆ˜: ${game.highScore}`, 24, COLORS.HUD, W/2, H/2+78);

      } else if(game.state===STATE_PLAY || game.state===STATE_PAUSE){
        ctx.font = font(28);
        ctx.fillStyle = COLORS.WHITE;
        ctx.textAlign="left"; ctx.textBaseline="middle";
        ctx.fillText(`ì ìˆ˜: ${game.score}`, 18, 36);
        ctx.fillText(`ì½¤ë³´: ${game.combo}`, 18, 68);

        const remain = Math.max(0, Math.ceil(game.timeLimit - game.elapsed));
        ctx.textAlign="right";
        ctx.fillText(`ë‚¨ì€ ì‹œê°„: ${remain}`, W-18, 36);
        ctx.textAlign="right";
        ctx.fillText(`ìµœëŒ€ ì ìˆ˜: ${game.highScore}`, W-18, 68);

        if(game.state===STATE_PAUSE){
          // ì¼ì‹œì •ì§€ ì˜¤ë²„ë ˆì´ ëŠë‚Œ
          ctx.fillStyle = "rgba(0,0,0,.35)";
          ctx.fillRect(0,0,W,H);
          drawTextCenter("ì¼ì‹œì •ì§€", 60, COLORS.WHITE, W/2, H/2-20);
          drawTextCenter("P ë˜ëŠ” ì¼ì‹œì •ì§€ ë²„íŠ¼ìœ¼ë¡œ ì¬ê°œ", 26, COLORS.HUD, W/2, H/2+40);
        }

      } else if(game.state===STATE_GAMEOVER){
        drawTextCenter("ê²Œì„ ì˜¤ë²„", 64, COLORS.RED, W/2, H/2-70);
        drawTextCenter(`ìµœì¢… ì ìˆ˜: ${game.score}`, 40, COLORS.WHITE, W/2, H/2-5);
        drawTextCenter(`ìµœëŒ€ ì ìˆ˜: ${game.highScore}`, 30, COLORS.WHITE, W/2, H/2+45);
        drawTextCenter("R ë˜ëŠ” ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘", 26, COLORS.HUD, W/2, H/2+120);

        if(topHint){
          drawTextCenter(topHint, 20, COLORS.HUD, W/2, H/2+160);
        }
      }
    }

    function loop(now){
      const dt = clamp((now-last)/1000, 0, 0.05);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ====== ë¦¬ë”ë³´ë“œ ======
    const boardBody = document.getElementById('board-body');

    function escapeHTML(s){
      return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
    }
    function formatDate(iso){
      try{ return new Date(iso).toLocaleDateString('ko-KR'); }catch{ return "-"; }
    }
    function renderBoard(rows){
      if(!rows || rows.length===0){
        boardBody.innerHTML = `<tr><td colspan="5">ì•„ì§ ë“±ë¡ëœ ì ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>`;
        return;
      }
      boardBody.innerHTML = rows.slice(0,10).map((r,i)=>{
        const safeName = escapeHTML(r.name);
        const score = Number(r.score)||0;
        const maxCombo = Number(r.maxCombo)||0;
        const when = formatDate(r.created_at);
        return `<tr>
          <td>${i+1}</td>
          <td>${safeName}</td>
          <td>${score}</td>
          <td>${maxCombo}</td>
          <td>${when}</td>
        </tr>`;
      }).join("");
    }

    // fetch íƒ€ì„ì•„ì›ƒ + 1íšŒ ì¬ì‹œë„
    async function fetchWithTimeout(url, options={}, ms=4500){
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), ms);
      try{
        return await fetch(url, { ...options, signal: ctrl.signal, cache:"no-store" });
      } finally {
        clearTimeout(t);
      }
    }
    async function fetchJsonRetry(url, options={}, ms=4500){
      // 1íšŒ ì¬ì‹œë„
      for(let attempt=0; attempt<2; attempt++){
        try{
          const res = await fetchWithTimeout(url, options, ms);
          if(!res.ok) throw new Error("http error");
          return await res.json();
        }catch(e){
          if(attempt===1) throw e;
          await new Promise(r=>setTimeout(r, 500));
        }
      }
    }

    const LB_CACHE_KEY = "wam_leaderboard_cache_v1";

    async function refreshLeaderboard(){
      try{
        const data = await fetchJsonRetry(`${API_BASE}/api/leaderboard`);
        renderBoard(data);
        localStorage.setItem(LB_CACHE_KEY, JSON.stringify({ at:Date.now(), data }));
      }catch{
        // ìºì‹œê°€ ìˆìœ¼ë©´ ìºì‹œë¡œ í‘œì‹œ
        const cached = localStorage.getItem(LB_CACHE_KEY);
        if(cached){
          try{
            const obj = JSON.parse(cached);
            renderBoard(obj.data);
            showToast("ë¦¬ë”ë³´ë“œ ë„¤íŠ¸ì›Œí¬ê°€ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ìµœê·¼ ìºì‹œë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.");
            return;
          }catch{}
        }
        boardBody.innerHTML = `<tr><td colspan="5">ë¦¬ë”ë³´ë“œë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</td></tr>`;
      }
    }

    // ====== Top10 ì €ì¥ ======
    const nameOverlay = document.getElementById('nameOverlay');
    const nicknameInput = document.getElementById('nickname');
    const submitNameBtn = document.getElementById('submitName');
    const cancelNameBtn = document.getElementById('cancelName');
    let pendingScore = null;
    let submitting = false;

    function normalizeNickname(name){
      return name.trim().replace(/\s+/g, " ");
    }
    function validateNickname(name){
      return /^[\p{L}0-9 _-]{2,12}$/u.test(name);
    }

    async function probeAndMaybeAskName(score, maxCombo){
      try{
        const data = await fetchJsonRetry(`${API_BASE}/api/score/probe`, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ score, maxCombo })
        });

        if(data.qualifies){
          topHint = "";
          pendingScore = { score, maxCombo };
          nicknameInput.value = "";
          nameOverlay.style.display = "flex";
          nicknameInput.focus();
        }else{
          const cutoff = Number(data.cutoffScore);
          if(Number.isFinite(cutoff) && cutoff > score){
            topHint = `Top 10ê¹Œì§€ ${cutoff - score}ì  ë¶€ì¡±í•©ë‹ˆë‹¤.`;
          }else{
            topHint = "Top 10ì— ë“¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë” ë†’ì€ ì ìˆ˜ë¡œ ë„ì „í•´ë³´ì„¸ìš”.";
          }
          showToast(topHint);
        }

        refreshLeaderboard();
      }catch{
        showToast("ì ìˆ˜ ì²˜ë¦¬ ì¤‘ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    }

    submitNameBtn.addEventListener('click', async ()=>{
      if(submitting) return;

      const name = normalizeNickname(nicknameInput.value);
      if(!validateNickname(name)){
        showToast("ë‹‰ë„¤ì„ í˜•ì‹ì´ ë§ì§€ ì•ŠìŠµë‹ˆë‹¤. (2~12ì, íŠ¹ìˆ˜ë¬¸ì ì œí•œ)");
        return;
      }
      if(!pendingScore){
        nameOverlay.style.display='none';
        return;
      }

      submitting = true;
      submitNameBtn.disabled = true;
      cancelNameBtn.disabled = true;

      try{
        const data = await fetchJsonRetry(`${API_BASE}/api/score/submit`, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ name, score: pendingScore.score, maxCombo: pendingScore.maxCombo })
        });

        nameOverlay.style.display='none';
        showToast("ë¦¬ë”ë³´ë“œì— ì €ì¥ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.");
        pendingScore = null;

        renderBoard(data.leaderboard || []);
      }catch{
        showToast("ì €ì¥ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }finally{
        submitting = false;
        submitNameBtn.disabled = false;
        cancelNameBtn.disabled = false;
      }
    });

    cancelNameBtn.addEventListener('click', ()=>{
      pendingScore = null;
      nameOverlay.style.display='none';
      showToast("ì €ì¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.");
    });

    nicknameInput.addEventListener('keydown', (e)=>{
      if(e.key==="Enter") submitNameBtn.click();
      if(e.key==="Escape") cancelNameBtn.click();
    });

    // ===== ì´ˆê¸° ë¡œë“œ =====
    refreshLeaderboard();

    // ===== íŒíŠ¸ ë¬¸êµ¬ ì—…ë°ì´íŠ¸(ìƒíƒœ ë°˜ì˜) =====
    const hintEl = document.getElementById('hint');
    setInterval(()=>{
      if(game.state === STATE_PLAY) hintEl.textContent = "íƒ€ê²©: í´ë¦­/í„°ì¹˜ Â· P ì¼ì‹œì •ì§€ Â· R ì¬ì‹œì‘";
      else if(game.state === STATE_PAUSE) hintEl.textContent = "ì¼ì‹œì •ì§€ ì¤‘ Â· P ë˜ëŠ” ì¼ì‹œì •ì§€ ë²„íŠ¼ìœ¼ë¡œ ì¬ê°œ";
      else if(game.state === STATE_GAMEOVER) hintEl.textContent = "ê²Œì„ ì˜¤ë²„ Â· R ë˜ëŠ” ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘";
      else hintEl.textContent = "Space ì‹œì‘ Â· ì‹œì‘ ë²„íŠ¼ í´ë¦­ ê°€ëŠ¥ Â· ëª¨ë°”ì¼ì€ í™”ë©´ í„°ì¹˜ë¡œ ì‹œì‘/íƒ€ê²©";
    }, 300);
  </script>
</body>
</html>
